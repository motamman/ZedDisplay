# /build-plugin-config

Generate a native Flutter configurator widget for a SignalK plugin.

## Arguments
- `$ARGUMENTS`: Plugin ID to configure (e.g., "signalk-autopilot"). If not provided, list available plugins and ask which one to configure.

## Overview

This skill generates a Flutter widget that provides a native configuration UI for a SignalK plugin, replacing the WebView fallback with a faster, theme-consistent, offline-capable experience.

## Workflow

### Step 1: Get Plugin Information

If no plugin ID is provided, fetch the list of available plugins:

```bash
# Get server URL from the app's connection (check lib/config/ or ask user)
curl -s "http://localhost:3000/signalk/v2/features" | jq '.plugins[] | {id, name}'
```

Ask the user which plugin to configure.

### Step 2: Fetch Plugin Schema

Get the plugin's JSON schema, UI schema, and current configuration:

```bash
curl -s "http://localhost:3000/skServer/plugins/{PLUGIN_ID}" | jq
```

The response includes:
- `schema`: JSON Schema defining configuration structure
- `uiSchema`: Optional hints for UI rendering
- `data.configuration`: Current configuration values

### Step 3: Analyze Schema

Parse the schema and identify:
- **Field types**: string, number, integer, boolean, array, object
- **Enums**: Fixed choices (for dropdowns/radios)
- **Required fields**: Must be filled
- **Nested objects**: For sections/groups
- **Arrays**: For dynamic lists
- **Patterns/formats**: For validation (email, uri, etc.)

### Step 4: Ask UI Preferences

For complex schemas, ask the developer:

1. **Grouping**: "How should fields be grouped?"
   - Single scrollable form
   - Tabbed sections
   - Expandable sections

2. **Enum display**: "How should enum fields be displayed?"
   - Dropdown (default)
   - Radio buttons
   - Segmented control

3. **Custom labels**: "Any fields needing custom labels?" (schema titles may be cryptic)

4. **Help text**: "Any fields needing additional help text?"

### Step 5: Generate Code

Create the configurator file at:
```
lib/plugin_configurators/configurators/{plugin_id_snake_case}_configurator.dart
```

Use this template structure:

```dart
import 'package:flutter/material.dart';
import '../base_plugin_configurator.dart';
import '../../services/signalk_service.dart';

/// Native configurator for {Plugin Name}
///
/// Generated by /build-plugin-config skill.
/// Schema source: {schema URL or "fetched from server"}
class {PluginName}Configurator extends BasePluginConfigurator {
  const {PluginName}Configurator({
    super.key,
    required super.signalKService,
    required super.pluginId,
    required super.initialConfig,
    super.onSaved,
  });

  @override
  State<{PluginName}Configurator> createState() => _{PluginName}ConfiguratorState();
}

class _{PluginName}ConfiguratorState extends BasePluginConfiguratorState<{PluginName}Configurator>
    with PluginConfigFormBuilders {
  // State variables for each config field
  // Example: String? _fieldName;

  @override
  void initState() {
    super.initState();
    // Initialize from widget.initialConfig
    // Example: _fieldName = widget.initialConfig['fieldName'] as String?;
  }

  @override
  Map<String, dynamic> get currentConfig => {
    // Return current state as config map
    // Example: 'fieldName': _fieldName,
  };

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // Error banner if present
          if (errorMessage != null) ...[
            buildErrorBanner()!,
            const SizedBox(height: 16),
          ],

          // Form fields go here
          // Use buildTextField, buildNumberField, buildSwitchField, buildDropdownField
          // Use buildSection to group related fields

          const SizedBox(height: 24),

          // Save button
          buildSaveButton(),
        ],
      ),
    );
  }
}
```

### Step 6: Register in Factory

Add the import and registration to `lib/plugin_configurators/plugin_configurator_registry.dart`:

```dart
// Add import at top
import 'configurators/{plugin_id_snake_case}_configurator.dart';

// Add to _configurators map
'{plugin-id}': ({
  Key? key,
  required SignalKService signalKService,
  required String pluginId,
  required Map<String, dynamic> initialConfig,
  VoidCallback? onSaved,
}) => {PluginName}Configurator(
  key: key,
  signalKService: signalKService,
  pluginId: pluginId,
  initialConfig: initialConfig,
  onSaved: onSaved,
),
```

## Field Type Mapping

| JSON Schema Type | Flutter Widget |
|------------------|----------------|
| `string` | `buildTextField()` |
| `string` + `enum` | `buildDropdownField()` |
| `string` + `format: password` | `buildTextField(obscure: true)` |
| `string` + `format: textarea` | `buildTextField(maxLines: 4)` |
| `number` / `integer` | `buildNumberField()` |
| `boolean` | `buildSwitchField()` |
| `array` of primitives | Custom list builder |
| `object` | `buildSection()` with nested fields |

## Example Output

For a plugin with this schema:
```json
{
  "title": "Simple Notifications",
  "properties": {
    "enabled": { "type": "boolean", "title": "Enable notifications" },
    "email": { "type": "string", "format": "email", "title": "Email address" },
    "threshold": { "type": "number", "minimum": 0, "maximum": 100 }
  }
}
```

Generate:
```dart
class SimpleNotificationsConfigurator extends BasePluginConfigurator {
  // ... constructor

  @override
  State<SimpleNotificationsConfigurator> createState() => _SimpleNotificationsConfiguratorState();
}

class _SimpleNotificationsConfiguratorState
    extends BasePluginConfiguratorState<SimpleNotificationsConfigurator>
    with PluginConfigFormBuilders {

  bool _enabled = false;
  String? _email;
  double? _threshold;

  @override
  void initState() {
    super.initState();
    _enabled = widget.initialConfig['enabled'] as bool? ?? false;
    _email = widget.initialConfig['email'] as String?;
    _threshold = (widget.initialConfig['threshold'] as num?)?.toDouble();
  }

  @override
  Map<String, dynamic> get currentConfig => {
    'enabled': _enabled,
    if (_email != null) 'email': _email,
    if (_threshold != null) 'threshold': _threshold,
  };

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          if (errorMessage != null) ...[
            buildErrorBanner()!,
            const SizedBox(height: 16),
          ],

          buildSwitchField(
            label: 'Enable notifications',
            value: _enabled,
            onChanged: (v) => setState(() => _enabled = v),
          ),

          buildTextField(
            label: 'Email address',
            value: _email,
            onChanged: (v) => setState(() => _email = v.isEmpty ? null : v),
            hint: 'user@example.com',
          ),

          buildNumberField(
            label: 'Threshold',
            value: _threshold,
            onChanged: (v) => setState(() => _threshold = v?.toDouble()),
            min: 0,
            max: 100,
          ),

          const SizedBox(height: 24),
          buildSaveButton(),
        ],
      ),
    );
  }
}
```

## Notes

- Always check if the plugin has a complex schema requiring multiple questions
- For very simple plugins (1-3 fields), skip the UI preference questions
- Preserve any existing configurator if regenerating - ask before overwriting
- Test the generated code compiles before marking complete
- The generated configurator should handle null values gracefully
